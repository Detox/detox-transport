// Generated by LiveScript 1.5.0
/**
 * @package Detox transport
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  var ROUTING_COMMANDS_OFFSET, PUBLIC_KEY_LENGTH, MAC_LENGTH, ROUTING_PATH_SEGMENT_TIMEOUT, MAX_DATA_SIZE, PACKET_SIZE, ROUTER_PACKET_SIZE, PEER_CONNECTION_TIMEOUT;
  ROUTING_COMMANDS_OFFSET = 10;
  PUBLIC_KEY_LENGTH = 32;
  MAC_LENGTH = 16;
  ROUTING_PATH_SEGMENT_TIMEOUT = 10;
  MAX_DATA_SIZE = Math.pow(2, 16) - 1;
  PACKET_SIZE = 512;
  ROUTER_PACKET_SIZE = PACKET_SIZE - 3;
  PEER_CONNECTION_TIMEOUT = 30;
  /**
   * @param {!Array<!Uint8Array>}	buffer
   * @param {!Uint8Array}			new_array
   */
  function update_dictionary_buffer(buffer, new_array){
    buffer[0] = buffer[1];
    buffer[1] = buffer[2];
    buffer[2] = buffer[3];
    buffer[3] = buffer[4];
    buffer[4] = new_array;
  }
  function Wrapper(detoxCrypto, detoxDht, detoxUtils, ronion, fixedSizeMultiplexer, asyncEventer, pako, simplePeer, wrtc){
    var bencode, array2hex, array2string, hex2array, string2array, are_arrays_equal, concat_arrays, ArrayMap, x$;
    bencode = detoxDht['bencode'];
    array2hex = detoxUtils['array2hex'];
    array2string = detoxUtils['array2string'];
    hex2array = detoxUtils['hex2array'];
    string2array = detoxUtils['string2array'];
    are_arrays_equal = detoxUtils['are_arrays_equal'];
    concat_arrays = detoxUtils['concat_arrays'];
    ArrayMap = detoxUtils['ArrayMap'];
    /**
     * @constructor
     *
     * @param {boolean}			initiator
     * @param {!Array<!Object>}	ice_servers
     * @param {number}			packets_per_second	Each packet send in each direction has exactly the same size and packets are sent at fixed rate (>= 1)
     *
     * @return {!DHT}
     */
    function P2P_transport(initiator, ice_servers, packets_per_second){
      var this$ = this;
      if (!(this instanceof P2P_transport)) {
        return new P2P_transport(ice_servers, packets_per_second);
      }
      asyncEventer.call(this);
      this._initiator = initiator;
      this._peer = simplePeer({
        'config': {
          'iceServers': ice_servers
        },
        'initiator': initiator,
        'trickle': false,
        'wrtc': wrtc
      });
      this._signal = new Promise(function(resolve, reject){
        this$._peer['once']('signal', function(signal){
          resolve(string2array(signal['sdp']));
        })['once']('close', reject);
      });
      this._signal['catch'](function(){});
      this._send_delay = 1000 / packets_per_second;
      this._sending = initiator;
      this._multiplexer = fixedSizeMultiplexer['Multiplexer'](MAX_DATA_SIZE, PACKET_SIZE);
      this._demultiplexer = fixedSizeMultiplexer['Demultiplexer'](MAX_DATA_SIZE, PACKET_SIZE);
      this._send_zlib_buffer = [new Uint8Array(0), new Uint8Array(0), new Uint8Array(0), new Uint8Array(0), new Uint8Array(0)];
      this._receive_zlib_buffer = [new Uint8Array(0), new Uint8Array(0), new Uint8Array(0), new Uint8Array(0), new Uint8Array(0)];
      this._peer['once']('connect', function(){
        this$['fire']('connected');
        this$._last_sent = +new Date;
        if (this$._sending) {
          this$._real_send();
        }
      })['once']('close', function(){
        this$['fire']('disconnected');
      })['on']('data', function(data){
        var demultiplexed_data, command, command_data;
        if (this$._sending || data.length !== PACKET_SIZE) {
          this$['destroy']();
        } else {
          this$._demultiplexer['feed'](data);
          while (this$._demultiplexer['have_more_data']()) {
            demultiplexed_data = this$._demultiplexer['get_data']();
            command = demultiplexed_data[0];
            command_data = demultiplexed_data.subarray(1);
            if (command < ROUTING_COMMANDS_OFFSET) {
              command_data = this$._zlib_decompress(command_data);
            }
            this$['fire']('data', command, command_data);
          }
          this$._sending = true;
          this$._real_send();
        }
      });
    }
    P2P_transport.prototype = {
      /**
       * @return {!Promise} Resolves with `Uint8Array` signaling data
       */
      'get_signaling': function(){
        return this._signal;
      }
      /**
       * @param {!Uint8Array} signaling As generated by `get_signaling()` method
       */,
      'set_signaling': function(signaling){
        this._peer['signal']({
          'type': this._initiator ? 'answer' : 'offer',
          'sdp': array2string(signaling)
        });
      }
      /**
       * @param {number}		command
       * @param {!Uint8Array}	data
       */,
      'send': function(command, data){
        var x$, data_with_header;
        if (command < ROUTING_COMMANDS_OFFSET) {
          data = this._zlib_compress(data);
        }
        x$ = data_with_header = new Uint8Array(data.length + 1);
        x$.set([command]);
        x$.set(data, 1);
        this._multiplexer['feed'](data_with_header);
      },
      'destroy': function(){
        this._destroyed = true;
        this._peer['destroy']();
      }
      /**
       * Send a block of multiplexed data to the other side
       */,
      _real_send: function(){
        var delay, this$ = this;
        delay = Math.max(0, this._send_delay - (new Date - this._last_sent));
        setTimeout(function(){
          var e;
          if (this$._destroyed) {
            return;
          }
          try {
            simplePeer.prototype['send'].call(this$, this$._multiplexer['get_block']());
            this$._sending = false;
            this$._last_sent = +new Date;
          } catch (e$) {
            e = e$;
            this$['emit']('error', e);
          }
        }, delay);
      }
      /**
       * @param {!Uint8Array} data
       *
       * @return {!Uint8Array}
       */,
      _zlib_compress: function(data){
        var result;
        result = pako['deflate'](data, {
          'dictionary': concat_arrays(this._send_zlib_buffer),
          'level': 1
        });
        update_dictionary_buffer(this._send_zlib_buffer, data);
        return result;
      }
      /**
       * @param {!Uint8Array} data
       *
       * @return {!Uint8Array}
       */,
      _zlib_decompress: function(data){
        var result;
        result = pako['inflate'](data, {
          'dictionary': concat_arrays(this._receive_zlib_buffer)
        });
        update_dictionary_buffer(this._receive_zlib_buffer, result);
        return result;
      }
    };
    P2P_transport.prototype = Object.assign(Object.create(asyncEventer.prototype), P2P_transport.prototype);
    Object.defineProperty(P2P_transport.prototype, 'constructor', {
      value: P2P_transport
    });
    /**
     * @param {!Uint8Array} data
     *
     * @return {!Uint8Array} Sometimes returns `Buffer` (depending on input type), but let's make Closure Compiler happy and specify `Uint8Array` for now
     */
    function blake2b_256(data){
      return data.constructor['from'](detoxCrypto['blake2b_256'](data));
    }
    /**
     * @param {!Object} message
     *
     * @return {!Uint8Array} Actually returns `Buffer`, but let's make Closure Compiler happy and specify `Uint8Array` for now
     */
    function encode_signature_data(message){
      return bencode['encode'](message).slice(1, -1);
    }
    /**
     * @constructor
     *
     * @param {!Uint8Array}	dht_public_key						Own ID (Ed25519 public key)
     * @param {number}		bucket_size							Size of a bucket from Kademlia design
     * @param {number}		state_history_size					How many versions of local history will be kept
     * @param {number}		values_cache_size					How many values will be kept in cache
     * @param {number}		fraction_of_nodes_from_same_peer	Max fraction of nodes originated from single peer allowed on lookup start
     *
     * @return {!DHT}
     */
    function DHT(dht_public_key, bucket_size, state_history_size, values_cache_size, fraction_of_nodes_from_same_peer){
      var this$ = this;
      fraction_of_nodes_from_same_peer == null && (fraction_of_nodes_from_same_peer = 0.2);
      if (!(this instanceof DHT)) {
        return new DHT(dht_public_key, bucket_size, state_history_size, values_cache_size, fraction_of_nodes_from_same_peer);
      }
      asyncEventer.call(this);
      this._dht = detoxDht['DHT'](dht_public_key, bucket_size, state_history_size, values_cache_size, fraction_of_nodes_from_same_peer)['on']('peer_error', function(peer_id){})['on']('peer_warning', function(peer_id){})['on']('connect_to', function(peer_peer_id, peer_id){})['on']('send', function(peer_id, command, payload){});
    }
    DHT.prototype = Object.create(asyncEventer.prototype);
    x$ = DHT.prototype;
    /**
     * @param {!Uint8Array} node_id
     *
     * @return {!Promise} Resolves with `!Array<!Uint8Array>`
     */
    x$['lookup'] = function(node_id){
      if (this._destroyed) {
        return;
      }
      return this._dht['lookup'](node_id);
    };
    /**
     * Generate message with introduction nodes that can later be published by any node connected to DHT (typically other node than this for anonymity)
     *
     * @param {!Uint8Array}			real_public_key		Ed25519 public key (real one, different from supplied in DHT constructor)
     * @param {!Uint8Array}			real_private_key	Corresponding Ed25519 private key
     * @param {!Array<!Uint8Array>}	introduction_nodes	Array of public keys of introduction points
     *
     * @return {!Uint8Array}
     */
    x$['generate_announcement_message'] = function(real_public_key, real_private_key, introduction_nodes){
      var time;
      time = parseInt(+new Date / 1000);
      return concat_arrays(this._dht['make_mutable_value'](real_public_key, real_private_key, time, concat_arrays(introduction_nodes)));
    };
    /**
     * @param {!Uint8Array} message
     *
     * @return {Uint8Array} Public key if signature is correct, `null` otherwise
     */
    x$['verify_announcement_message'] = function(message){
      var real_public_key, data, payload;
      real_public_key = message.subarray(0, PUBLIC_KEY_LENGTH);
      data = message.subarray(PUBLIC_KEY_LENGTH);
      payload = this._dht['verify_value'](real_public_key, data);
      if (!payload || payload[1].length % PUBLIC_KEY_LENGTH) {
        return null;
      } else {
        return real_public_key;
      }
    };
    /**
     * Publish message with introduction nodes (typically happens on different node than `generate_announcement_message()`)
     *
     * @param {!Uint8Array} message
     */
    x$['publish_announcement_message'] = function(message){
      var real_public_key, data;
      if (this._destroyed) {
        return;
      }
      real_public_key = message.subarray(0, PUBLIC_KEY_LENGTH);
      data = message.subarray(PUBLIC_KEY_LENGTH);
      this._dht['put_value'](real_public_key, data);
    };
    /**
     * Find nodes in DHT that are acting as introduction points for specified public key
     *
     * @param {!Uint8Array}	target_public_key
     * @param {!Function}	success_callback
     * @param {!Function}	failure_callback
     */
    x$['find_introduction_nodes'] = function(target_public_key, success_callback, failure_callback){
      var hash;
      if (this._destroyed) {
        return;
      }
      hash = blake2b_256(target_public_key);
      this._dht['get'](hash, function(arg$, result){
        var introduction_nodes_bulk, introduction_nodes, i$, to$, i;
        if (!result || !result['v']) {
          if (typeof failure_callback == 'function') {
            failure_callback();
          }
          return;
        }
        introduction_nodes_bulk = Uint8Array.from(result['v']);
        introduction_nodes = [];
        if (introduction_nodes_bulk.length % PUBLIC_KEY_LENGTH !== 0) {
          return;
        }
        for (i$ = 0, to$ = introduction_nodes_bulk.length / PUBLIC_KEY_LENGTH; i$ < to$; ++i$) {
          i = i$;
          introduction_nodes.push(introduction_nodes_bulk.subarray(i * PUBLIC_KEY_LENGTH, (i + 1) * PUBLIC_KEY_LENGTH));
        }
        success_callback(introduction_nodes);
      });
    };
    x$['destroy'] = function(callback){
      if (this._destroyed) {
        return;
      }
      this._destroyed = true;
      this._dht['destroy']();
    };
    Object.defineProperty(DHT.prototype, 'constructor', {
      value: DHT
    });
    /**
     * @constructor
     *
     * @param {!Uint8Array}	dht_private_key			X25519 private key that corresponds to Ed25519 key used in `DHT` constructor
     * @param {number}		max_pending_segments	How much segments can be in pending state per one address
     *
     * @return {!Router}
     *
     * @throws {Error}
     */
    function Router(dht_private_key, max_pending_segments){
      var this$ = this;
      max_pending_segments == null && (max_pending_segments = 10);
      if (!(this instanceof Router)) {
        return new Router(dht_private_key, max_pending_segments);
      }
      asyncEventer.call(this);
      this._encryptor_instances = ArrayMap();
      this._rewrapper_instances = ArrayMap();
      this._last_node_in_routing_path = ArrayMap();
      this._multiplexers = ArrayMap();
      this._demultiplexers = ArrayMap();
      this._established_routing_paths = ArrayMap();
      this._ronion = ronion(ROUTER_PACKET_SIZE, PUBLIC_KEY_LENGTH, MAC_LENGTH, max_pending_segments)['on']('activity', function(address, segment_id){
        this$['fire']('activity', address, segment_id);
      })['on']('create_request', function(address, segment_id, command_data){
        var source_id, encryptor_instance, e, rewrapper_instance, encryptor_instances, rewrapper_instances;
        if (this$._destroyed) {
          return;
        }
        source_id = concat_arrays([address, segment_id]);
        if (this$._encryptor_instances.has(source_id)) {
          return;
        }
        encryptor_instance = detoxCrypto['Encryptor'](false, dht_private_key);
        try {
          encryptor_instance['put_handshake_message'](command_data);
        } catch (e$) {
          e = e$;
          return;
        }
        this$._ronion['create_response'](address, segment_id, encryptor_instance['get_handshake_message']());
        this$._ronion['confirm_incoming_segment_established'](address, segment_id);
        this$._multiplexers.set(source_id, fixedSizeMultiplexer['Multiplexer'](MAX_DATA_SIZE, this$._max_packet_data_size));
        this$._demultiplexers.set(source_id, fixedSizeMultiplexer['Demultiplexer'](MAX_DATA_SIZE, this$._max_packet_data_size));
        if (!encryptor_instance['ready']()) {
          return;
        }
        rewrapper_instance = encryptor_instance['get_rewrapper_keys']().map(detoxCrypto['Rewrapper']);
        encryptor_instances = ArrayMap();
        encryptor_instances.set(address, encryptor_instance);
        rewrapper_instances = ArrayMap();
        rewrapper_instances.set(address, rewrapper_instance);
        this$._encryptor_instances.set(source_id, encryptor_instances);
        this$._rewrapper_instances.set(source_id, rewrapper_instances);
        this$._last_node_in_routing_path.set(source_id, address);
      })['on']('send', function(address, packet){
        this$['fire']('send', address, packet);
      })['on']('data', function(address, segment_id, target_address, command, command_data){
        var source_id, last_node_in_routing_path, demultiplexer, data;
        if (this$._destroyed) {
          return;
        }
        source_id = concat_arrays([address, segment_id]);
        last_node_in_routing_path = this$._last_node_in_routing_path.get(source_id);
        if (!are_arrays_equal(target_address, last_node_in_routing_path)) {
          return;
        }
        demultiplexer = this$._demultiplexers.get(source_id);
        if (!demultiplexer) {
          return;
        }
        demultiplexer['feed'](command_data);
        if (demultiplexer['have_more_data']()) {
          data = demultiplexer['get_data']();
          this$['fire']('data', address, segment_id, command, data);
        }
      })['on']('encrypt', function(data){
        var address, segment_id, target_address, plaintext, source_id, encryptor_instance, ref$;
        if (this$._destroyed) {
          return;
        }
        address = data['address'];
        segment_id = data['segment_id'];
        target_address = data['target_address'];
        plaintext = data['plaintext'];
        source_id = concat_arrays([address, segment_id]);
        encryptor_instance = (ref$ = this$._encryptor_instances.get(source_id)) != null ? ref$.get(target_address) : void 8;
        if (!encryptor_instance || !encryptor_instance['ready']()) {
          return;
        }
        data['ciphertext'] = encryptor_instance['encrypt'](plaintext);
      })['on']('decrypt', function(data){
        var address, segment_id, target_address, ciphertext, source_id, encryptor_instance, ref$, e;
        if (this$._destroyed) {
          return;
        }
        address = data['address'];
        segment_id = data['segment_id'];
        target_address = data['target_address'];
        ciphertext = data['ciphertext'];
        source_id = concat_arrays([address, segment_id]);
        encryptor_instance = (ref$ = this$._encryptor_instances.get(source_id)) != null ? ref$.get(target_address) : void 8;
        if (!encryptor_instance || !encryptor_instance['ready']()) {
          return;
        }
        try {
          data['plaintext'] = encryptor_instance['decrypt'](ciphertext);
        } catch (e$) {
          e = e$;
          /**
           * Since we don't use all of Ronion features and only send data between initiator and responder, we can destroy unnecessary encryptor
           * instances and don't even try to decrypt anything, which makes data forwarding less CPU intensive
           */
          encryptor_instance['destroy']();
          this$._encryptor_instances.get(source_id)['delete'](target_address);
        }
      })['on']('wrap', function(data){
        var address, segment_id, target_address, unwrapped, source_id, rewrapper_instance, ref$, ref1$;
        if (this$._destroyed) {
          return;
        }
        address = data['address'];
        segment_id = data['segment_id'];
        target_address = data['target_address'];
        unwrapped = data['unwrapped'];
        source_id = concat_arrays([address, segment_id]);
        rewrapper_instance = (ref$ = this$._rewrapper_instances.get(source_id)) != null ? (ref1$ = ref$.get(target_address)) != null ? ref1$[0] : void 8 : void 8;
        if (!rewrapper_instance) {
          return;
        }
        data['wrapped'] = rewrapper_instance['wrap'](unwrapped);
      })['on']('unwrap', function(data){
        var address, segment_id, target_address, wrapped, source_id, rewrapper_instance, ref$, ref1$;
        if (this$._destroyed) {
          return;
        }
        address = data['address'];
        segment_id = data['segment_id'];
        target_address = data['target_address'];
        wrapped = data['wrapped'];
        source_id = concat_arrays([address, segment_id]);
        rewrapper_instance = (ref$ = this$._rewrapper_instances.get(source_id)) != null ? (ref1$ = ref$.get(target_address)) != null ? ref1$[1] : void 8 : void 8;
        if (!rewrapper_instance) {
          return;
        }
        data['unwrapped'] = rewrapper_instance['unwrap'](wrapped);
      });
      this._max_packet_data_size = this._ronion['get_max_command_data_length']();
    }
    Router.prototype = {
      /**
       * Process routing packet coming from node with specified ID
       *
       * @param {!Uint8Array} node_id
       * @param {!Uint8Array} packet
       */
      'process_packet': function(node_id, packet){
        if (this._destroyed) {
          return;
        }
        this._ronion['process_packet'](node_id, packet);
      }
      /**
       * Construct routing path through specified nodes
       *
       * @param {!Array<!Uint8Array>} nodes IDs of the nodes through which routing path must be constructed, last node in the list is responder
       *
       * @return {!Promise} Will resolve with ID of the route or will be rejected if path construction fails
       */,
      'construct_routing_path': function(nodes){
        var this$ = this;
        if (this._destroyed) {
          return Promise.reject();
        }
        nodes = nodes.slice();
        return new Promise(function(resolve, reject){
          var last_node_in_routing_path, first_node, encryptor_instances, rewrapper_instances, fail, x25519_public_key, first_node_encryptor_instance, segment_establishment_timeout, route_id, source_id;
          last_node_in_routing_path = nodes[nodes.length - 1];
          first_node = nodes.shift();
          encryptor_instances = ArrayMap();
          rewrapper_instances = ArrayMap();
          fail = function(){
            this$._destroy_routing_path(first_node, route_id);
            reject('Routing path creation failed');
          };
          x25519_public_key = detoxCrypto['convert_public_key'](first_node);
          if (!x25519_public_key) {
            fail();
            return;
          }
          first_node_encryptor_instance = detoxCrypto['Encryptor'](true, x25519_public_key);
          encryptor_instances.set(first_node, first_node_encryptor_instance);
          function create_response_handler(address, segment_id, command_data){
            var e, current_node, current_node_encryptor_instance, segment_extension_timeout;
            if (!are_arrays_equal(first_node, address) || !are_arrays_equal(route_id, segment_id)) {
              return;
            }
            clearTimeout(segment_establishment_timeout);
            this$._ronion['off']('create_response', create_response_handler);
            try {
              first_node_encryptor_instance['put_handshake_message'](command_data);
            } catch (e$) {
              e = e$;
              fail();
              return;
            }
            if (!first_node_encryptor_instance['ready']()) {
              fail();
              return;
            }
            rewrapper_instances.set(first_node, first_node_encryptor_instance['get_rewrapper_keys']().map(detoxCrypto['Rewrapper']));
            this$._ronion['confirm_outgoing_segment_established'](first_node, route_id);
            this$._multiplexers.set(source_id, fixedSizeMultiplexer['Multiplexer'](MAX_DATA_SIZE, this$._max_packet_data_size));
            this$._demultiplexers.set(source_id, fixedSizeMultiplexer['Demultiplexer'](MAX_DATA_SIZE, this$._max_packet_data_size));
            function extend_request(){
              var x25519_public_key;
              if (!nodes.length) {
                this$._established_routing_paths.set(source_id, [first_node, route_id]);
                resolve(route_id);
                return;
              }
              function extend_response_handler(address, segment_id, command_data){
                var e;
                if (!are_arrays_equal(first_node, address) || !are_arrays_equal(route_id, segment_id)) {
                  return;
                }
                this$._ronion['off']('extend_response', extend_response_handler);
                clearTimeout(segment_extension_timeout);
                if (!command_data.length) {
                  fail();
                  return;
                }
                try {
                  current_node_encryptor_instance['put_handshake_message'](command_data);
                } catch (e$) {
                  e = e$;
                  fail();
                  return;
                }
                if (!current_node_encryptor_instance['ready']()) {
                  fail();
                  return;
                }
                rewrapper_instances.set(current_node, current_node_encryptor_instance['get_rewrapper_keys']().map(detoxCrypto['Rewrapper']));
                this$._ronion['confirm_extended_path'](first_node, route_id);
                extend_request();
              }
              this$._ronion['on']('extend_response', extend_response_handler);
              current_node = nodes.shift();
              x25519_public_key = detoxCrypto['convert_public_key'](current_node);
              if (!x25519_public_key) {
                fail();
                return;
              }
              current_node_encryptor_instance = detoxCrypto['Encryptor'](true, x25519_public_key);
              encryptor_instances.set(current_node, current_node_encryptor_instance);
              segment_extension_timeout = setTimeout(function(){
                this$._ronion['off']('extend_response', extend_response_handler);
                fail();
              }, ROUTING_PATH_SEGMENT_TIMEOUT * 1000);
              this$._ronion['extend_request'](first_node, route_id, current_node, current_node_encryptor_instance['get_handshake_message']());
            }
            extend_request();
          }
          this$._ronion['on']('create_response', create_response_handler);
          segment_establishment_timeout = setTimeout(function(){
            this$._ronion['off']('create_response', create_response_handler);
            fail();
          }, ROUTING_PATH_SEGMENT_TIMEOUT * 1000);
          route_id = this$._ronion['create_request'](first_node, first_node_encryptor_instance['get_handshake_message']());
          source_id = concat_arrays([first_node, route_id]);
          this$._encryptor_instances.set(source_id, encryptor_instances);
          this$._rewrapper_instances.set(source_id, rewrapper_instances);
          this$._last_node_in_routing_path.set(source_id, last_node_in_routing_path);
        });
      }
      /**
       * Destroy routing path constructed earlier
       *
       * @param {!Uint8Array} node_id		First node in routing path
       * @param {!Uint8Array} route_id	Identifier returned during routing path construction
       */,
      'destroy_routing_path': function(node_id, route_id){
        this._destroy_routing_path(node_id, route_id);
      }
      /**
       * Max data size that will fit into single packet without fragmentation
       *
       * @return {number}
       */,
      'get_max_packet_data_size': function(){
        return this._max_packet_data_size;
      }
      /**
       * Send data to the responder on specified routing path
       *
       * @param {!Uint8Array}	node_id		First node in routing path
       * @param {!Uint8Array}	route_id	Identifier returned during routing path construction
       * @param {number}		command		Command from range `0..245`
       * @param {!Uint8Array}	data
       */,
      'send_data': function(node_id, route_id, command, data){
        var source_id, target_address, multiplexer, data_block;
        if (this._destroyed) {
          return;
        }
        if (data.length > MAX_DATA_SIZE) {
          return;
        }
        source_id = concat_arrays([node_id, route_id]);
        target_address = this._last_node_in_routing_path.get(source_id);
        multiplexer = this._multiplexers.get(source_id);
        if (!multiplexer) {
          return;
        }
        multiplexer['feed'](data);
        while (multiplexer['have_more_blocks']()) {
          data_block = multiplexer['get_block']();
          this._ronion['data'](node_id, route_id, target_address, command, data_block);
        }
      }
      /**
       * Destroy all of the routing path constructed earlier
       */,
      'destroy': function(){
        var this$ = this;
        if (this._destroyed) {
          return;
        }
        this._destroyed = true;
        this._established_routing_paths.forEach(function(arg$){
          var address, segment_id;
          address = arg$[0], segment_id = arg$[1];
          this$._destroy_routing_path(address, segment_id);
        });
      }
      /**
       * @param {!Uint8Array} address
       * @param {!Uint8Array} segment_id
       */,
      _destroy_routing_path: function(address, segment_id){
        var source_id, encryptor_instances;
        source_id = concat_arrays([address, segment_id]);
        encryptor_instances = this._encryptor_instances.get(source_id);
        if (!encryptor_instances) {
          return;
        }
        encryptor_instances.forEach(function(encryptor_instance){
          encryptor_instance['destroy']();
        });
        this._encryptor_instances['delete'](source_id);
        this._rewrapper_instances['delete'](source_id);
        this._last_node_in_routing_path['delete'](source_id);
        this._multiplexers['delete'](source_id);
        this._demultiplexers['delete'](source_id);
        this._established_routing_paths['delete'](source_id);
      }
    };
    Router.prototype = Object.assign(Object.create(asyncEventer.prototype), Router.prototype);
    Object.defineProperty(Router.prototype, 'constructor', {
      value: Router
    });
    return {
      'ready': detoxCrypto['ready'],
      'DHT': DHT,
      'P2P_transport': P2P_transport,
      'Router': Router,
      'MAX_DATA_SIZE': MAX_DATA_SIZE
    };
  }
  if (typeof define === 'function' && define['amd']) {
    define(['@detox/crypto', '@detox/dht', '@detox/utils', 'ronion', 'fixed-size-multiplexer', 'async-eventer', 'pako', '@detox/simple-peer'], Wrapper);
  } else if (typeof exports === 'object') {
    module.exports = Wrapper(require('@detox/crypto'), require('@detox/dht'), require('@detox/utils'), require('ronion'), require('fixed-size-multiplexer'), require('async-eventer'), require('pako'), require('@detox/simple-peer'), require('wrtc'));
  } else {
    this['detox_transport'] = Wrapper(this['detox_crypto'], this['detox_dht'], this['detox_utils'], this['ronion'], this['fixed_size_multiplexer'], this['async_eventer'], this['pako'], this['SimplePeer']);
  }
}).call(this);
